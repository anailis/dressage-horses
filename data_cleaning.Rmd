---
title: "Data Cleaning"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description of the Data

Data were scraped from the web into a SQLite3 database with two tables: one containing show results and one containing pedigree data.

``` {r data extraction}
# get raw data from sqlite3 database
library(tidyverse)
library(RSQLite)
library(lubridate)
conn <- dbConnect(RSQLite::SQLite(), "dressage.db")

ped <- dbGetQuery(conn,'SELECT * FROM pedigree')
shows <- dbGetQuery(conn, 'SELECT * FROM show_results')
```

``` {r describing ped}
head(ped)
dim(ped)
```

The pedigree table contains 1081 rows and 8 columns. Each row represents a horse, who is identified either by the column `horse_id` or the column `horse_ueln`. The goal of tidying is to obtain a pedigree dataframe where every individual has a single, unique identifier and is contained within their own row. This includes individuals who are at the outset only included in the `sire_id`/`sire_ueln` or `dam_id`/`dam_ueln` columns. Duplicate data is likely to be a problem due to the scraping method used to obtain the data - duplicate rows should be identified and removed. NA should be consistently used to represent missing values (e.g. absence of recorded parents).`sex` should be recoded as 0 for females, 1 for males, and NA for missing data. `dob` refers to the horse's date of birth, which is given in one of two formats in the raw dataframe: DD/MM/YYYY or DD/MM/YYYY (age). These will be tidied into year of birth for each individual (YYYY).  

After attempting to clean the ped dataframe, I have come to the decision to omit dam information from any final analyses. This is because it is plagued with several issues that indicate it is of low quality. One individual can be listed multiple times with different dams and some dams are mislabelled as males or sires. 

``` {r describing shows}
head(shows)
dim(shows)
```

The shows table has 18033 rows and 9 columns. Each row represents a single show result for a single horse/rider combination. In this table, horses are described only by `horse_id`, and thus this is the only way to link them to the pedigree table. Riders are identified by their unique `rider_id`. `sex` and `dob` must be encoded as they are in the pedigree table and will be used as a quality control measures to ensure agreement between records with the same `horse_id` in both tables. `shows` also contains: the country code of the nation in which the show took place (`location`), the level of event (`event_type`), the title of the competition (`comp_title`), the position of the combination (`position`) and their score (`score`).

## Clean the Pedigree Table

First, I will replace blank cells with NA and remove any rows which appear multiple times. 76 duplicate rows are removed.

``` {r remove duplicates}
ped$horse_id <- str_trim(str_remove(ped$horse_id, "\\(.*"))

ped <- as_tibble(ped)
ped[ped==''] <- NA

ped <- ped %>%
  mutate_all(str_trim) %>%
  distinct()

dim(ped)
```

### Clean Sex Column

Next, I will standardise the sexes and obtain year of birth. Although the distinction between geldings and stallions may be informative, 140 male individuals are not distinguished as stallion or gelding. For now, I will collapse all males into a single category (1). 

``` {r standardise sex}
table(ped$sex)

ped$sex_raw <- ped$sex
ped_sex_raw <- ped

ped <- ped %>%
  mutate(sex=replace(sex, sex == "Mare", "0")) %>%
  mutate(sex=replace(sex, sex == "Stallion", "1")) %>%
  mutate(sex=replace(sex, sex == "Gelding", "1")) %>%
  mutate(sex=replace(sex, sex == "Male", "1")) %>%
  mutate(sex=replace(sex, sex == "Female", "0"))

table(ped$sex)
ped$sex_raw <- NULL
ped <- ped %>%
  distinct()
```

This leaves us with 280 females, 701 males, and no individuals missing sex. 

### Create yob Column

I obtain the year of birth for each individual from the `dob` column. 

``` {r create yob}
tail(ped$dob)

ped$dob <- str_trim(str_remove(ped$dob, "\\(.*"))

tail(ped$dob)

ped$yob <- year(dmy(ped$dob))

head(ped$yob, n = 20)
head(ped$dob, n = 20)

ped$dob <- NULL
```

### Dealing with Duplication 

Although initially I filtered out all identical rows, there is still a problem with duplicate IDs and UELNs arising in the data. 35 UELNs are present more than once in `horse_ueln`, and 41 IDs are present more than once in `horse_id`. I am going to remove this issue before proceeding any further. 

``` {r id duplicates}
sum(table(ped$horse_id) > 1)
sum(table(ped$horse_ueln) > 1)

getDupIds <- function(df, id_type) {
  list <- df %>%
    count_(id_type) %>%
    filter(n > 1) %>%
    pull(id_type)
  
  list <- list[!is.na(list)]
  
  if (length(list) != 0) {
    return(list)
  } else {
    return("No duplicate ids.")
  }
}

dup_uelns <- getDupIds(ped, "horse_ueln")
dup_ids <- getDupIds(ped, "horse_id")  

length(dup_uelns)
length(dup_ids)

ped %>%
  filter(horse_id %in% dup_ids) %>%
  arrange(horse_id)

ped %>% 
  filter(horse_ueln %in% dup_uelns) %>%
  arrange(horse_ueln)
```

I prepare a series of functions that identify where duplicated rows differ (NA in both rows is counted as a match). 

``` {r identify source of duplication}
getDupRows <- function(id, df, id_type) {
  df <- df[!is.na(df[[id_type]]),]
  return(df[df[[id_type]]==id,])
}

makeOutputMatrix <- function(df) {
  matrix(0, ncol = 3, nrow = ncol(df), 
         dimnames = list(c(colnames(df)), c("Match", "Different", "NA")))
}

identifyMatches <- function(row1, row2, outmatrix) {
  for (lll in 1:ncol(row1)) {
    if (is.na(row1[,lll] == row2[,lll])) {
      if (is.na(row1[,lll]) & is.na(row2[,lll])) {
        outmatrix[lll, "Match"] <- outmatrix[lll, "Match"] + 1
      } else {
        outmatrix[lll, "NA"] <- outmatrix[lll, "NA"] + 1 
      }
    } else {
      if (row1[,lll] == row2[,lll]) {
        outmatrix[lll, "Match"] <- outmatrix[lll, "Match"] + 1
      } else {
        outmatrix[lll, "Different"] <- outmatrix[lll, "Different"] + 1
      }
    }
  }
  return(outmatrix)
}

compareDupRows <- function(id, df, id_type) {
  outmatrix <- makeOutputMatrix(df)
  duprows <- getDupRows(id, df, id_type)
  
  if (nrow(duprows) <= 1) {
    return("ID is not a duplicate.")
  }
  
  for (iii in 1:nrow(duprows)) {
    for (jjj in 1:nrow(duprows)) {
      if (iii < jjj) {
        outmatrix <- identifyMatches(duprows[iii,], duprows[jjj,], outmatrix)
      }
    }
  }
  return(outmatrix)
}

compareAllDupRows <- function(dupids, df, id_type) {
  outmatrix <- makeOutputMatrix(df)
  for (id in dupids) {
    temp <- compareDupRows(id, df, id_type)
    outmatrix <- outmatrix + temp
  }
  return(outmatrix)
}

pass1 <- compareAllDupRows(dup_ids, ped, "horse_id") + compareAllDupRows(dup_uelns, ped, "horse_ueln")
pass1
```

An ID may have one record that contains `dam_ueln`, `horse_ueln`, `sire_id`, or `dam_id` but is NA for this field in the duplicated record. In such cases, it makes sense to remove the record that has the least information. More concerning is the inconsistency in dam uelns: where the same horse is recorded twice, with two different dams listed.

```{r find rows differing by na}
# split dup uelns and ids into those that differ by NA only and those with different data 
identifyRowsDifferingbyNA <- function(id, dupRows) {
  if (nrow(dupRows) <= 1) {
    return("ID is not a duplicate.")
  }
  
  for (iii in 1:nrow(dupRows)) {
    for (jjj in 1:nrow(dupRows)) {
      if (iii < jjj & sum(is.na(dupRows[1,])) != sum(is.na(dupRows[2,]))) {
        return(id)
      }
    }
  }
}

getIdsDifferingByNA <- function(id_list, df, id_type) {
  idsDifferentByNA <- c()
  for (id in id_list) {
    dupRows <- getDupRows(id, df, id_type)
    idsDifferentByNA <- append(idsDifferentByNA, identifyRowsDifferingbyNA(id, dupRows), after = length(idsDifferentByNA))
  }
  return(idsDifferentByNA)
}

ids_differbyna <- getIdsDifferingByNA(dup_ids, ped, "horse_id")
ped %>%
  filter(horse_id %in% ids_differbyna) %>%
  arrange(horse_id)
```

``` {r remove rows differing by na}
getRowNumsToRemove <- function(id, df, id_type) {
  li_toremove <- c()
  li <- which(df[[id_type]]==id)
  
  for (iii in 1:(length(li)-1)) {
    
    if (sum(is.na(df[li[iii],])) > sum(is.na(df[li[iii+1],]))) {
      li_toremove <- append(li_toremove, li[iii], length(li_toremove))
    }
    
    if (sum(is.na(df[li[iii],])) < sum(is.na(df[li[iii+1],]))) {
      li_toremove <- append(li_toremove, li[iii+1], length(li_toremove))
    }
    
  }
  
  return(li_toremove)
}

rowsWithLessData <- function(id_list, df, id_type) {
  li_toremove <- c()
  
  for (id in id_list) {
    li_toremove <- append(li_toremove, getRowNumsToRemove(id, df, id_type), length(li_toremove))
  }
  
  return(li_toremove)
}

ped <- ped[-(rowsWithLessData(ids_differbyna, ped, "horse_id")),]

dup_uelns <- getDupIds(ped, "horse_ueln")

uelns_differbyna <- getIdsDifferingByNA(dup_uelns, ped, "horse_ueln")
ped %>%
  filter(horse_ueln %in% uelns_differbyna) %>%
  arrange(horse_ueln)

ped <- ped[-(rowsWithLessData(uelns_differbyna, ped, "horse_ueln")),]

dup_uelns <- getDupIds(ped, "horse_ueln")
dup_ids <- getDupIds(ped, "horse_id")

pass2 <- compareAllDupRows(dup_ids, ped, "horse_id") + compareAllDupRows(dup_uelns, ped, "horse_ueln")
pass2

ped %>%
  filter(horse_id %in% dup_ids) %>%
  arrange(horse_id)

ped %>%
  filter(horse_ueln %in% dup_uelns) %>%
  arrange(horse_ueln)
```

One horse, with ID GER13813, has rows with the same number of NAs but different rows which have these NAs. I sort this one exception manually. 

``` {r}
ped <- ped %>%
  mutate(horse_ueln = ifelse(horse_id == "GER13813", "276333330111490", horse_ueln))

ped <- ped[-getRowNumsToRemove("GER13813", ped, "horse_id"),]

dup_ids <- getDupIds(ped, "horse_id")
pass3 <- compareAllDupRows(dup_ids, ped, "horse_id") + compareAllDupRows(dup_uelns, ped, "horse_ueln")
pass3
```

The current dataset will be set aside, so that informative missingness can be assessed at a later point. 

``` {r}
#for future analyses of these individuals 
ped_dups <- ped
ped <- ped %>%
  filter(!(horse_id %in% dup_ids)) %>%
  filter(!(horse_ueln %in% dup_uelns))

getDupIds(ped, "horse_ueln")
getDupIds(ped, "horse_id")
```

### Individuals Without Rows

It is likely that there are some individuals listed as sires or dams that do not have their own rows. These individuals will be considered as part of the base generation - they must still have their own records, with all parental IDs listed as NA. Having two ID systems poses a problem: sires and dams may have an id, a ueln, or both.

The aggregation plot below shows a concerning trend: individuals favour id identifiers, whereas parents favour ueln identifiers. It is possible that we have the same individual represented multiple times in the data, under two different identifiers. We can see from the plot that there are no cases when a sire or dam has both an id and a ueln. However, if an individual is a dam/sire but also has their own row, it may be possible to infer missing ids or uelns, as in the vast majority of cases (~87%) horses with their own rows have both uelns and ids.

``` {r id missingness}
library(VIM)

aggr(ped, numbers = T, prop = c(T, F))

parents_only <- ped %>%
  select(dam_id, dam_ueln, sire_id, sire_ueln)

aggr(parents_only, numbers = T, prop = c(T, F))
```

Given that there are no cases where a sire and dam have both a ueln and an id, we can paste these columns together to make the analysis easier. This leaves us with 132 dams and 182 sires in our dataset. Of these, 52 of the dams also have their own record and 91 of the sires have their own record. 

``` {r create new sire and dam cols}
ped <- ped %>% 
  mutate(dam = coalesce(dam_id, dam_ueln)) %>%
  mutate(sire = coalesce(sire_id, sire_ueln))

length(unique(na.omit(ped$dam)))
length(unique(na.omit(ped$sire)))

ped %>% 
  filter(!is.na(dam)) %>%
  select(dam) %>%
  filter(dam %in% ped$horse_id | dam %in% ped$horse_ueln) %>%
  distinct() %>%
  count()

ped %>% 
  filter(!is.na(sire)) %>%
  filter(sire %in% ped$horse_id | sire %in% ped$horse_ueln) %>%
  select(sire) %>%
  distinct() %>%
  count()
```

A test of quality is whether the sex is as expected for all of these individuals. Surprisingly, 6 individuals listed as dams are listed as male. Unlike the mares, all of the sires are listed as males.

``` {r check for correct sex}
## dams
dam_ids <- ped %>% 
  filter(!is.na(dam)) %>%
  select(dam) %>%
  distinct() %>%
  pull(dam)

dam_records <- ped %>% 
  filter(horse_id %in% dam_ids | horse_ueln %in% dam_ids) %>%
  select(horse_id, horse_ueln, sex)

nrow(dam_records)
aggr(dam_records, numbers = T, prop = c(T, F))

table(dam_records$sex)

## sires
sire_ids <- ped %>% 
  filter(!is.na(sire)) %>%
  select(sire) %>%
  distinct() %>%
  pull(sire)

sire_records <- ped %>% 
  filter(horse_id %in% sire_ids | horse_ueln %in% sire_ids) %>%
  select(horse_id, horse_ueln, sex)

nrow(sire_records)
aggr(sire_records, numbers = T, prop = c(T, F))

table(sire_records$sex)
```

#### Decision to Omit Dam Information

This is the second inconsistency I have observed in this dam data, and thus I have chosen not to take it forward to future analyses. I also remove the now unnecessary `sire_ueln` and `sire_id` columns.

``` {r}
ped_withdams <- ped
ped$dam <- NULL
ped$dam_ueln <- NULL
ped$dam_id <- NULL
ped$sire_ueln <- NULL
ped$sire_id <- NULL
head(ped)
```

### Ensure Each Sire has a Row

There are 92 sires listed in the `sire` column that do not yet have their own record. Here I give these individuals their own rows, with everything other than ID set to NA.

``` {r}
sires_wo_rows <- ped %>%
  filter(!(sire %in% horse_id) & !(sire %in% horse_ueln)) %>%
  select(sire) %>%
  distinct() %>%
  pull()

length(sires_wo_rows)

ped <- rbind(ped, data.frame(horse_id = NA, sex = 1, horse_ueln = sires_wo_rows, yob = NA, sire = NA))

tail(ped)
```

## Clean the Shows Table

To begin, I will assign each show a unique identifier. Seven of the individuals with show results in this table are not included in the pedigree table, and are thus discarded. I also remove team show results, as these are the sum of all individuals in the team.

``` {r id shows, remove team results}
head(shows)
summary(shows)

shows$show_id <- c(1:nrow(shows))
shows$score <- as.numeric(shows$score)

shows <- shows %>% 
  filter(horse_id %in% ped$horse_id)

shows %>%
  group_by(comp_title) %>%
  summarise(mean = mean(score, na.rm = T)) %>%
  filter(mean > 100)
  
shows <- shows %>%
  filter(!str_detect(comp_title, "Team"))
```

A histogram is used to identify any other outliers. There is a peak between 0 and 20, which is highly unusual. These points are exclusively from young horse shows, which have different scoring systems. All young horse shows are removed from the dataset, leaving an approximately normal distribution of show scores. Althougher the dataset contains 16,352 show records, 548 of which are NA.

``` {r investigate outliers}
hist(shows$score)

shows %>%
  group_by(comp_title) %>%
  summarise(mean = mean(score, na.rm = T)) %>%
  filter(mean < 30)

shows %>%
  filter(score < 30)

shows <- shows %>% 
  filter(!str_detect(comp_title, "YH"))

summary(shows$score)
nrow(shows)
```

I hypothesise that these NAs may represent individuals who did not complete competition, due to retirement, for example. There are three categories for non-completion in this dataset: EL (elimination), DSQ (disqualification), and WD (withdrawn). There are 125, 7, and 148 occurances of these, respectively, within the data. The scores are always NA when one of these labels is present. Scores for these individuals will be imputed in the exploratory analysis. 

This leaves 218 unaccounted for NA scores. They are enriched for "final classifications" which would be an overall position, rather than a single show's score. I remove these, and leave the rest for investigations of missingness during exploratory analyses. 

This is all the cleaning required for the show results. They will be subject to further simple manipulations (e.g. mean per combination) later. 

``` {r}
unique(shows$position)
shows %>%
  filter(position == "RET" | position == "DSQ" | position == "WD") %>%
  count(position)

shows %>%
  filter(!(position == "RET" | position == "DSQ" | position == "WD")) %>%
  filter(is.na(score)) %>%
  count(comp_title)

shows <- shows %>% 
  filter(!str_detect(comp_title, "Final Classification"))

sum(is.na(shows$horse_id))
sum(is.na(shows$rider_id))
```

``` {r update database}
dbWriteTable(conn, "clean_pedigree", ped, overwrite = T)
dbWriteTable(conn, "clean_shows", shows, overwrite = T)

dbDisconnect(conn)
```











