---
title: "Data Cleaning"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description of the Data

Data were scraped from the web into a SQLite3 database with two tables: one containing show results and one containing pedigree data.

``` {r data extraction}
# get raw data from sqlite3 database
library(tidyverse)
library(RSQLite)
library(lubridate)
conn <- dbConnect(RSQLite::SQLite(), "dressage.db")

ped <- dbGetQuery(conn,'SELECT * FROM pedigree')
shows <- dbGetQuery(conn, 'SELECT * FROM show_results')
```

``` {r describing ped}
head(ped)
dim(ped)
```

The pedigree table contains 1081 rows and 8 columns. Each row represents a horse, who is identified either by the column `horse_id` or the column `horse_ueln`. The goal of tidying is to obtain a pedigree dataframe where every individual has a single, unique identifier and is contained within their own row. This includes individuals who are at the outset only included in the `sire_id`/`sire_ueln` or `dam_id`/`dam_ueln` columns. Duplicate data is likely to be a problem due to the scraping method used to obtain the data - duplicate rows should be identified and removed. NA should be consistently used to represent missing values (e.g. absence of recorded parents).`sex` should be recoded as 0 for females, 1 for males, and NA for missing data. `dob` refers to the horse's date of birth, which is given in one of two formats in the raw dataframe: DD/MM/YYYY or DD/MM/YYYY (age). These will be tidied into year of birth for each individual (YYYY).  

``` {r describing shows}
head(shows)
dim(shows)
```

The shows table has 18033 rows and 9 columns. Each row represents a single show result for a single horse/rider combination. In this table, horses are described only by `horse_id`, and thus this is the only way to link them to the pedigree table. Riders are identified by their unique `rider_id`. `sex` and `dob` must be encoded as they are in the pedigree table and will be used as a quality control measures to ensure agreement between records with the same `horse_id` in both tables. `shows` also contains: the country code of the nation in which the show took place (`location`), the level of event (`event_type`), the title of the competition (`comp_title`), the position of the combination (`position`) and their score (`score`).

## Clean the Pedigree Table

First, I will replace blank cells with NA and remove any rows which appear multiple times. 76 duplicate rows are removed.

``` {r remove duplicates}
ped$horse_id <- str_trim(str_remove(ped$horse_id, "\\(.*"))

ped <- as_tibble(ped)
ped[ped==''] <- NA

ped <- ped %>%
  mutate_all(str_trim) %>%
  distinct()

dim(ped)
```

### Clean Sex Column

Next, I will standardise the sexes and obtain year of birth. Although the distinction between geldings and stallions may be informative, 140 male individuals are not distinguished as stallion or gelding. For now, I will collapse all males into a single category (1), but I retain a copy of the `sex` column (`sex_raw`) in case I would like to come back to this. 

``` {r standardise sex}
table(ped$sex)

ped$sex_raw <- ped$sex

ped <- ped %>%
  mutate(sex=replace(sex, sex == "Mare", "0")) %>%
  mutate(sex=replace(sex, sex == "Stallion", "1")) %>%
  mutate(sex=replace(sex, sex == "Gelding", "1")) %>%
  mutate(sex=replace(sex, sex == "Male", "1")) %>%
  mutate(sex=replace(sex, sex == "Female", "0"))

table(ped$sex)
```

This leaves us with 280 females, 701 males, and no individuals missing sex. 

### Create yob Column

I obtain the year of birth for each individual from the `dob` column. 

``` {r create yob}
tail(ped$dob)

ped$dob <- str_trim(str_remove(ped$dob, "\\(.*"))

tail(ped$dob)

ped$yob <- year(dmy(ped$dob))

head(ped$yob, n = 20)
head(ped$dob, n = 20)
```

### Dealing with Duplication 

Although initially I filtered out all identical rows, there is still a problem with duplicate IDs and UELNs arising in the data. 35 UELNs are present more than once in `horse_ueln`, and 41 IDs are present more than once in `horse_id`. I am going to remove this issue before proceeding any further. 

``` {r id duplicates}
sum(table(ped$horse_id) > 1)
sum(table(ped$horse_ueln) > 1)

dup_uelns <- ped %>%
  filter(!is.na(horse_ueln)) %>%
  count(horse_ueln) %>%
  filter(n > 1) %>%
  pull(horse_ueln)

dup_ids <- ped %>%
  filter(!is.na(horse_id)) %>%
  count(horse_id) %>%
  filter(n > 1) %>%
  pull(horse_id)

ped %>%
  filter(horse_id %in% dup_ids) %>%
  arrange(horse_id)

ped %>% 
  filter(horse_ueln %in% dup_uelns) %>%
  arrange(horse_ueln)
```

I prepare a series of functions that identify where duplicated rows differ (NA in both rows is counted as a match). 

``` {r identify source of duplication}
getDupRows <- function(id, df, id_type) {
  df <- df[!is.na(df[[id_type]]),]
  return(df[df[[id_type]]==id,])
}

makeOutputMatrix <- function(df) {
  matrix(0, ncol = 3, nrow = ncol(df), 
         dimnames = list(c(colnames(df)), c("Match", "Different", "NA")))
}

identifyMatches <- function(row1, row2, outmatrix) {
  for (lll in 1:ncol(row1)) {
    if (is.na(row1[,lll] == row2[,lll])) {
      if (is.na(row1[,lll]) & is.na(row2[,lll])) {
        outmatrix[lll, "Match"] <- outmatrix[lll, "Match"] + 1
      } else {
        outmatrix[lll, "NA"] <- outmatrix[lll, "NA"] + 1 
      }
    } else {
      if (row1[,lll] == row2[,lll]) {
        outmatrix[lll, "Match"] <- outmatrix[lll, "Match"] + 1
      } else {
        outmatrix[lll, "Different"] <- outmatrix[lll, "Different"] + 1
      }
    }
  }
  return(outmatrix)
}

compareDupRows <- function(id, df, id_type) {
  outmatrix <- makeOutputMatrix(df)
  duprows <- getDupRows(id, df, id_type)
  for (iii in 1:nrow(duprows)) {
    for (jjj in 1:nrow(duprows)) {
      if (iii < jjj) {
        outmatrix <- identifyMatches(duprows[iii,], duprows[jjj,], outmatrix)
      }
    }
  }
  return(outmatrix)
}

compareAllDupRows <- function(dupids, df, id_type) {
  outmatrix <- makeOutputMatrix(df)
  for (id in dupids) {
    temp <- compareDupRows(id, df, id_type)
    outmatrix <- outmatrix + temp
  }
  return(outmatrix)
}

compareAllDupRows(dup_ids, ped, "horse_id") + compareAllDupRows(dup_uelns, ped, "horse_ueln")
```

An ID may have one record that contains `dam_ueln`, `horse_ueln`, `sire_id`, or `dam_id` but is NA for this field in the duplicated record. In such cases, it makes sense to remove the record that has the least information. Duplicated IDs are most likely to differ in their `dam_ueln` and their `sex_raw`, even when both of these fields have data. In the case of `sex_raw`, this is likely to be due to a coding of the same individual as `stallion` and `male`, for example, as all duplicated records are in agreement about cleaned sex. Therefore, we can ignore this. More concerning is the inconsistency in dam ids. 

``` {r}
#remove rows which differ only in sex


#remove rows which have less data than their duplicate 
idLessInfoRows <- function(id, df, id_type) {
  df <- df[!is.na(df[[id_type]]),]
  rowNums <- which(df[[id_type]]==id)
  for (iii in rowNums) {
    for (jjj in rowNums) {
      if (iii < jjj) {
        if (sum(is.na(df[iii,])) == sum(is.na(df[jjj,]))) {
        } else {
          if (sum(is.na(df[iii,])) > sum(is.na(df[jjj,]))) {
            return(iii)
          }
          if (sum(is.na(df[iii,])) < sum(is.na(df[jjj,]))) {
            return(jjj)
          }
        }
      }
    }
  }
}

listLessInfoRows <- function(dupids, df, id_type) {
  to_remove <- list()
  counter <- 1
  for (id in dupids) {
    to_remove[[counter]] <- idLessInfoRows(id, df, id_type)
    counter <- counter + 1
  }
  return(compact(to_remove))
}

rmLessInfoRows <- function(dupids, df, id_type) {
  to_remove <- listLessInfoRows(dupids, df, id_type)
  for (iii in 1:length(to_remove)) {
    df <- df[-c(to_remove[[iii]]),]
  }
  return(df)
}

test <- listLessInfoRows(dup_ids, ped, "horse_id")
length(listLessInfoRows(dup_uelns, ped, "horse_ueln"))

ped <- rmLessInfoRows(dup_ids, ped, "horse_id")
ped <- rmLessInfoRows(dup_uelns, ped, "horse_ueln")
```

### Individuals Without Rows

It is likely that there are some individuals listed as sires or dams that do not have their own rows. These individuals will be considered as part of the base generation - they must still have their own records, with all parental IDs listed as NA. Having two ID systems poses a problem: sires and dams may have an id, a ueln, or both.

The aggregation plot below shows a concerning trend: individuals favour id identifiers, whereas parents favour ueln identifiers. It is possible that we have the same individual represented multiple times in the data, under two different identifiers. We can see from the plot that there are no cases when a sire or dam has both an id and a ueln. However, if an individual is a dam/sire but also has their own row, it may be possible to infer missing ids or uelns, as in the vast majority of cases (~87%) horses with their own rows have both uelns and ids.

``` {r id missingness}
library(VIM)

id_missingness <- ped %>%
  select(horse_id, horse_ueln, sire_id, sire_ueln, dam_id, dam_ueln)

aggr(id_missingness, numbers = T, prop = c(T, F))
```

Given that there are no cases where a sire and dam have both a ueln and an id, we can paste these columns together to make the analysis easier. This leaves us with 148 dams and 185 sires in our dataset. Of these, 64 of the dams also have their own record and 100 of the sires have their own record. 

``` {r create new sire and dam cols}
ped <- ped %>% 
  mutate(dam = coalesce(dam_id, dam_ueln)) %>%
  mutate(sire = coalesce(sire_id, sire_ueln))

length(unique(na.omit(ped$dam)))
length(unique(na.omit(ped$sire)))

ped %>% 
  filter(!is.na(dam)) %>%
  select(dam) %>%
  filter(dam %in% ped$horse_id | dam %in% ped$horse_ueln) %>%
  distinct() %>%
  count()

ped %>% 
  filter(!is.na(sire)) %>%
  filter(sire %in% ped$horse_id | sire %in% ped$horse_ueln) %>%
  select(sire) %>%
  distinct() %>%
  count()
```

A test of quality is whether the sex is as expected for all of these individuals. Surprisingly, 8 individuals listed as dams are listed as male. This investigation also flags up another potential issue: when we retreive the records of these 64 dams, we obtain 67 rows. This is most likely an issue with the double ID system (individuals or their parents are represented more than once, using different combinations of IDs).

Indeed, although there are 67 unique records, we observe duplicate UELNs and IDs when we look at these individually. Some of these can be removed by calling `distinct()` after filtering out the parental columns, which tells us that a single individual may currently have multiple records with different parents recorded (e.g. because a different identifier is used to refer to the parent in different cases). This issue of duplication is extremely prevalent in this dataset because of the nature of identifier system used by the source, and I will return to this to do further corrections later on. 

Likewise for the sires, 100 sires correspond to 114 rows and duplicated UELNs and IDs are present. However, unlike the mares, all of the sires are listed as males.

``` {r check for correct sex}
## dams
dam_ids <- ped %>% 
  filter(!is.na(dam)) %>%
  select(dam) %>%
  distinct() %>%
  pull(dam)

dam_records <- ped %>% 
  filter(horse_id %in% dam_ids | horse_ueln %in% dam_ids) %>%
  select(horse_id, horse_ueln, sex, sex_raw)

nrow(dam_records)
aggr(dam_records, numbers = T, prop = c(T, F))
  
sum(table(dam_records$horse_id) > 1)
sum(table(dam_records$horse_ueln) > 1)

table(dam_records$sex)
table(dam_records$sex_raw)

## sires
sire_ids <- ped %>% 
  filter(!is.na(sire)) %>%
  select(sire) %>%
  distinct() %>%
  pull(sire)

sire_records <- ped %>% 
  filter(horse_id %in% sire_ids | horse_ueln %in% sire_ids) %>%
  select(horse_id, horse_ueln, sex, sex_raw)

nrow(sire_records)
aggr(sire_records, numbers = T, prop = c(T, F))
  
sum(table(sire_records$horse_id) > 1)
sum(table(sire_records$horse_ueln) > 1)

table(sire_records$sex)
```

#### Dams Listed as Males

I will have a brief look into how these 6 males mislabelled as dams (or vice versa) may have arisen. 

``` {r offspring of mislabelled dams}
mislabelled_dams <- dam_records %>%
  filter(sex == 1) %>%
  select(horse_id, horse_ueln) %>%
  distinct()

mislabelled_dams

ped %>%
  filter(dam %in% mislabelled_dams$horse_id | dam %in% mislabelled_dams$horse_ueln)

ped %>%
  filter(horse_id %in% dup_ids) %>%
  arrange(horse_id) 
```


