---
title: "Exploratory Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction


The SQLite database `dressage.db` contains the cleaned pedigree and show data in the tables `clean_pedigree` and `clean_shows`, respectively. 

``` {r}
library(tidyverse)
library(RSQLite)

conn <- dbConnect(RSQLite::SQLite(), "dressage.db")

ped <- dbGetQuery(conn,'SELECT * FROM clean_pedigree')
shows <- dbGetQuery(conn, 'SELECT * FROM clean_shows')
```

In this exploratory analyses, I want to better understand how well sires and riders are represented in my data, examine the data for covariates, explore and deal with any missing data, and come up with a model.

``` {r}
summary(shows)

for (iii in c("horse_id", "sex", "rider_id", "yob")) {
  shows[[iii]] <- as.factor(shows[[iii]])
}

for (iii in c("score", "yob")) {
  shows[[iii]] <- as.numeric(shows[[iii]])
}

# fill in all id columns
for (horse in 1:nrow(ped)) {
  if (is.na(ped[horse,"horse_ueln"])) {
    ped[horse,"horse_ueln"] <- ped[horse,"horse_id"]
  }
  
  if (is.na(ped[horse,"horse_id"])) {
    ped[horse,"horse_id"] <- ped[horse,"horse_ueln"]
  }
}

sum(is.na(ped$horse_id))
sum(is.na(ped$horse_ueln))

# if a sire has an id, replace its id in `sire` with this
for (horse in 1:nrow(ped)) {
  ueln <- ped[horse,"horse_ueln"]
  if (ueln %in% ped$sire) {
    ped[!is.na(ped$sire) & ped$sire==ueln,"sire"] <- ped[horse,"horse_id"]
  }
}

summary(ped)

for (iii in c("horse_id", "horse_ueln", "sire", "sex")) {
  ped[[iii]] <- as.factor(ped[[iii]])
}
```

## Summary Information

The dataset contains information on 1031 horses, with 14,871 show records available on 681 of these horses. 843 horses have sire information available, and are descended from 183 sires. The show data has results for 664 riders. I create a new column, `combination` which represents the combination of horse and rider. There are 899 horse/rider combinations in the data, thus in some cases the same rider must ride multiple horses.

``` {r summary stats}
nrow(ped)
nrow(shows)
sum(!is.na(ped$sire))
length(unique(ped$sire))
length(unique(shows$horse_id))
length(unique(shows$rider_id))

shows$combination <- paste0(shows$rider_id, shows$horse_id)

length(unique(shows$combination))
```

## Creating a Measure of Success

I am interested in using this dataset to explore what factors influence success in dressage horses. So first, I need to use the available data to create a measure of success. This will be derived from the show `score`. This data has a single outlier of `score` 0 and 413 NAs. Given that 0 is an impossible score, I simply omit this outlier.

``` {r outliers}
summary(shows$score)

shows <- shows %>%
  filter(score > 0 | is.na(score))

hist(shows$score)
```

As I established when cleaning the data, most of the NAs represent failure to complete the test (DSQ = disqualified, WD = withdrawn, RET = retired, EL = eliminated). These classifications are never associated with a non-NA score. Only 55 NAs are not explained by failure to complete the test (out of 14,870 shows). I want to know whether these are randomly missing, or associated with any other feature of the data (e.g. horse, rider, show type). All shows with NA in both `score` and `position` were attributed to a single horse, id SWE04871, and these are the only shows listed for this individual. Thus, I am forced to omit this individual. 

``` {r missing scores}
shows %>%
  filter((position %in% c("DSQ", "EL", "RET", "WD"))) %>%
  count(score)

shows %>%
  filter(is.na(score)) %>%
  filter(!(position %in% c("DSQ", "EL", "RET", "WD"))) %>%
  count(horse_id)

shows %>%
  filter(is.na(position) & is.na(score)) %>%
  count(horse_id)

shows %>%
  filter(horse_id == "SWE04871") %>%
  count()

shows <- shows %>%
  filter(horse_id != "SWE04871")

ped <- ped %>%
  filter(horse_id != "SWE04871")
```

The remaining 5 NA scores are attributable to just two other horses, ids GER43431 and NED04088. Unlike SWE04871, these horses have plenty of other non-NA shows. Three of these were "historical rules", and are the only "historical rules" in the dataset. I could not find any further information on the meaning of this classification, but I assume that it will not be relevant to my analyses, and thus omit them. The other shows are freestyle to music, but there are plenty of these shows with non-NA score entries (~2500). Both shows were competed by the same rider/horse combination, but this combination has 25 other results. Given the massive scale of this data, which is otherwise complete, I feel that it is safe to omit these two datapoints, although I cannot explain why they are missing. 

``` {r}
shows %>% 
  filter(horse_id %in% c("GER43431", "NED04088")) %>%
  count(horse_id)

shows %>%
  filter(is.na(score)) %>%
  filter(!(position %in% c("DSQ", "EL", "RET", "WD"))) %>%
  count(comp_title)

shows[str_detect(shows$comp_title, "Hist"),]

shows <- shows %>%
  filter(!comp_title == "Hist - Historical Rule")

nrow(shows[str_detect(shows$comp_title, "Music"),])

shows %>%
  filter(is.na(score)) %>%
  filter(!(position %in% c("DSQ", "EL", "RET", "WD"))) 

shows %>%
  filter(rider_id == "10019451" & horse_id == "GER43431")

shows <- shows %>%
  filter(!is.na(score) | (position %in% c("DSQ", "EL", "RET", "WD")))

shows %>%
  filter(is.na(score) & !(position %in% c("RET", "WD", "EL", "DSQ")))
```

I want `score` to be a continuous variable for analysis. This raises the question of how to represent the various categories of non-completion in `score`. I believe that failing to complete a show due to elimination or disqualification should inevitably be detrimental to a combination's measure of success as they indicate that the combination performed poorly in that show. Retirement and withdrawal are slightly less clear, because they may not necessarily represent poor performance. For example, a rider may choose to retire when they realise they cannot beat the current leading score, but that doesn't necessarily mean their performance was bad, just not good enough to take home a trophy. Withdrawal may occur due to some irrelevant circumstances, such as illness or travel issues.

Thus, at least to start with, I propose two crude imputations of these categories. 260 shows marked WD or RET will be assigned a score randomly drawn from a normal distribution (68.81511, 3.269806). The score shows are approximately normally distributed, so this distribution seems appropriate. I have overlayed this distribution (green) over the true distribution (black) in the graph below. Essentially, we are assuming that withdrawal or retirement means that a combination is less likely than normal to have achieved an especially high score, but on the whole their scores are similar to that of other shows. I choose to sample shows from a distribution rather than assign a single value, because I do not want to compromise the variance or normality of my data. 

Note that due to the random nature of the imputation generation, values may vary slightly in the html output. I immediately export all imputed data into new tables in `dressage.db`. 

``` {r impute WD and RET}
wd_ret_mean <- mean(shows$score, na.rm = T) - 1
wd_ret_sd <- sd(shows$score, na.rm = T)/1.5

wd_ret_points <- seq(-4, 4, length = 100) * wd_ret_sd + wd_ret_mean
wd_ret_dist <- dnorm(wd_ret_points, wd_ret_mean, wd_ret_sd)

ggplot() +
  geom_point(aes(x = wd_ret_points, y = wd_ret_dist), color = "green") + 
  geom_freqpoly(data = shows, aes(x = score), stat = "density") + 
  xlab("Score") +
  ylab("Probability or Frequency")

shows %>% 
  filter(position %in% c("WD", "RET")) %>%
  count()

wt_ret_imputed <- rnorm(260, wd_ret_mean, wd_ret_sd)

shows[shows$position %in% c("WD", "RET"),]$score <- wt_ret_imputed

shows %>% 
  filter(position %in% c("WD", "RET"))

#dbWriteTable(conn, "shows_imputed")
```

On the other hand, I want to penalise individuals who are eliminated (EL) or disqualified (DSQ). Thus, I impute values from a normal distribution (66.56, 4.904709). The mean of this distribution is the 25th percentile of the data. Thus, I am penalising combinations for having been eliminated or disqualified. 

``` {r impute EL and DSQ}
quantile(shows$score, probs = 0.25, na.rm = T)
el_dsq_mean <- 66.565
el_dsq_sd <- sd(shows$score, na.rm = T)/1.5

el_dsq_points <- seq(-4, 4, length = 100) * el_dsq_sd + el_dsq_mean
el_dsq_dist <- dnorm(el_dsq_points, el_dsq_mean, el_dsq_sd)

ggplot() +
  geom_point(aes(x = el_dsq_points, y = el_dsq_dist), color = "green") + 
  geom_freqpoly(data = shows, aes(x = score), stat = "density") + 
  xlab("Score") +
  ylab("Probability or Frequency")

shows %>%
  filter(position %in% c("DSQ", "EL")) %>%
  count()

el_dsq_imputed <- rnorm(98, el_dsq_mean, el_dsq_sd)

shows[shows$position %in% c("DSQ", "EL"),]$score <- el_dsq_imputed

sum(is.na(shows$position))

#dbWriteTable(conn, "shows_imputed", shows, overwrite = F)
```

Next, I take the mean score for each combination as a measure of dressage success. I do this with a SQL query.

``` {r take mean score}
shows <- dbGetQuery(conn, 'SELECT horse_id, rider_id, combination, AVG(score) AS mean_score, yob, sex, COUNT(combination) AS show_count FROM shows_imputed
           GROUP BY combination')
```

## Relatedness

Sires in the dataset have on average 4.6 offspring (range: 1 to 67).
There are only 2 instances of sires with an ID rather than a UELN and neither of them have a ueln. 

``` {r sire relatedness}
mean(table(ped$sire))
range(table(ped$sire))
hist(table(ped$sire), breaks = 30, xlab = "Number of Offspring per Sire")
```

The mean number of horses per rider is 1.36 (range: 1 to 7). The mean number of riders per horse is 1.32 (range: 1 to 5).

``` {r riders}
mean(table(shows$rider_id))
range(table(shows$rider_id))
hist(table(shows$rider_id), breaks = 8, xlab = "Number of Horses per Rider")

mean(table(shows$horse_id))
range(table(shows$horse_id))
hist(table(shows$horse_id), breaks = 6, xlab = "Number of Riders per Horse")
```

## Covariates

The covariates I want to consider are sex, number of shows competed in, and year of birth.

``` {r}
library(extrafont)
library(ggthemes)

theme_fei <- function() {
  theme_hc(base_size = 12, base_family = "Segoe UI") %+replace%
    theme(panel.background  = element_blank(),,
          axis.ticks = element_line(colour = "grey"),
          axis.line = element_line(color = "grey"))
}

ggplot(aes(x = mean_score), data = shows) + 
  geom_histogram(fill = "#A276AE", color = "#F7F6EE") + 
  labs(x = "Mean Dressage Score per Combination", y = "Frequency") + 
  theme_fei()

ggplot(aes(x = show_count), data = shows) + 
  geom_histogram(fill = "#A276AE", color = "#F7F6EE") + 
  labs(x = "Number of Shows per Combination", y = "Frequency") + 
  theme_fei()

ggplot(aes(y = mean_score, x = sex), data = shows) + 
  geom_boxplot(fill = "#A276AE") + 
  geom_jitter(alpha = 0.2) +
  labs(x = "Sex of Horse", y = "Mean Dressage Score per Combination") +
  theme_fei()

ggplot(aes(y = mean_score, x = yob), data = shows) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Horse Year of Birth", y = "Mean Dressage Score per Combination") +
  theme_fei()

ggplot(aes(y = mean_score, x = show_count), data = shows) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Number of Shows per Combination", y = "Mean Dressage Score per Combination") +
  theme_fei()
```

Next I am going to mutate the ped table so it contains mean score for a horse (regardless of rider) and also number of offspring for sires. This will allow me to ask questions such as whether a sire's performance influences the number of offspring he has. 

``` {r}
horses <- dbGetQuery(conn, 'SELECT horse_id, AVG(score) AS mean_score, COUNT(combination) AS show_count FROM shows_imputed
           GROUP BY horse_id')
horses <- horses %>%
  full_join(ped, by = "horse_id") %>%
  select(horse_id, horse_ueln, sire, mean_score, show_count, sex, yob) %>%
  rowwise() %>%
  mutate(offspring = sum(horse_ueln == ped$sire, na.rm = T) + sum(horse_id == ped$sire, na.rm = T))

sires <- horses %>%
  filter(offspring > 0) %>%
  select(horse_id, horse_ueln, offspring, mean_score)

# note that by only taking individuals with show scores the sample is smaller
offspring <- horses %>%
  filter(!is.na(sire) & !is.na(mean_score))

sires$offspring_mean_score <- 0
sires$offspring_max_score <- 0

for (col in c("horse_ueln", "horse_id")) {
  sires[[col]] <- as.character(sires[[col]])
}

for (indiv in 1:nrow(sires)) {
  if (sires[indiv,]$horse_ueln %in% offspring$sire | sires[indiv,]$horse_id %in% offspring$sire) {
    sires[indiv, "offspring_mean_score"] <- mean(offspring[offspring$sire == sires[indiv,]$horse_ueln | offspring$sire == sires[indiv,]$horse_id,]$mean_score, na.rm = T)
    sires[indiv, "offspring_max_score"] <- max(offspring[offspring$sire == sires[indiv,]$horse_ueln | offspring$sire == sires[indiv,]$horse_id,]$mean_score, na.rm = T)
  } else {
    # individuals who have only offspring that haven't competed will get NA
    sires[indiv, "offspring_mean_score"] <- NA
    sires[indiv, "offspring_max_score"] <- NA
  }
}
```


``` {r}
ggplot(aes(x = show_count), data = horses) + 
  geom_histogram(fill = "#A276AE", color = "#F7F6EE") + 
  labs(x = "Number of Shows per Horse", y = "Frequency") + 
  theme_fei()

ggplot(aes(y = mean_score, x = sex), data = horses) + 
  geom_boxplot(fill = "#A276AE") + 
  geom_jitter(alpha = 0.2) +
  labs(x = "Sex of Horse", y = "Mean Dressage Score per Horse") +
  theme_fei()

ggplot(aes(y = mean_score, x = yob), data = horses) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Horse Year of Birth", y = "Mean Dressage Score per Horse") +
  theme_fei()

ggplot(aes(y = mean_score, x = show_count), data = horses) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Number of Shows per Horse", y = "Mean Dressage Score per Horse") +
  theme_fei()

ggplot(aes(y = mean_score, x = offspring), data = sires) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Number of Offspring per Sire", y = "Mean Dressage Score per Sire") +
  theme_fei()

ggplot(aes(y = offspring_mean_score, x = offspring), data = sires) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Number of Offspring per Sire", y = "Mean Dressage Score of all Offspring") +
  theme_fei()

ggplot(aes(y = offspring_max_score, x = offspring), data = sires) +
  geom_point(color = "#363151", alpha = 0.2) + 
  labs(x = "Number of Offspring per Sire", y = "Maximum Mean Dressage Score per Sire") +
  theme_fei()
```

## Designing the Model

In the first model I choose to fit year of birth of horse and number of shows per combination as fixed effects. I am somewhat concerned that this is not the correct way to fit number of shows, given that the variance of mean dressage score decreases with number of shows competed in.

The problem I have encountered is that horses are referred to by IDs in the show_results table and UELNs in the ped table, but the same ID system must be used to build the A matrix as is used to record the show results. This means I MUST move to a single ID system to run the model! I have lost a bunch of sires by doing the joins that I did to calculate summary statistics for offspring! Back to the drawing board 

``` {r}
# filter out individuals with show results not in the pedigree 
shows <- shows %>%
  filter(horse_id %in% ped$horse_id)

```

``` {r}
library(asreml)
library(visPedigree)

ped$dam <- NA

for (fac in c("sex", "horse_id", "rider_id")) {
  shows[[fac]] <- as.factor(shows[[fac]])
}

ped_asreml <- ped %>%
  select(horse_id, sire, dam)

ped_asreml <- tidyped(ped_asreml)

ainv <- ainverse(ped_asreml)

model1 <- asreml(fixed = mean_score ~ 1 + show_count + yob + sex, random = ~ vm(horse_id, ainv) + idv(rider_id), residual = ~ idv(units), data = shows)

dbDisconnect()
```
